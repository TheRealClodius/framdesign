{
  "version": "1.0.249a595d",
  "gitCommit": "d665ace",
  "buildTimestamp": "2026-01-14T13:46:39.642Z",
  "tools": [
    {
      "toolId": "end_voice_session",
      "version": "1.0.0",
      "category": "action",
      "description": "GRACEFUL VOICE SESSION TERMINATION TOOL (Voice Mode Only)\n\nWHEN TO USE:\n- User explicitly asks to end the voice session or switch to text\n- Conversation has naturally concluded and user indicates they're done\n- You need to show something that requires text mode (complex diagrams, detailed explanations, code)\n- User asks a question but wants the answer delivered in text chat instead of voice\n\nDO NOT USE:\n- User just pauses or stops talking (wait for them)\n- You're in the middle of answering a question\n- As punishment (use ignore_user for that)\n\nEFFECT: Ends voice session gracefully, allowing conversation to continue in text mode if desired.",
      "sideEffects": "writes",
      "idempotent": true,
      "requiresConfirmation": false,
      "allowedModes": [
        "voice"
      ],
      "latencyBudgetMs": 500,
      "jsonSchema": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "reason"
        ],
        "properties": {
          "reason": {
            "type": "string",
            "enum": [
              "user_request",
              "task_complete",
              "switch_to_text"
            ],
            "description": "Why the session is ending: user_request (user asked to end), task_complete (conversation finished), switch_to_text (showing content better suited for text)"
          },
          "final_message": {
            "type": "string",
            "description": "Optional brief farewell message to speak before ending. Keep it short (1-2 sentences). Example: 'Ending voice session. Feel free to continue in text chat.'",
            "minLength": 5,
            "maxLength": 200
          }
        }
      },
      "summary": "Gracefully terminates voice session while allowing conversation to continue in text mode. Voice mode only.",
      "documentation": "# end_voice_session\n\n## Summary\n\nGraceful voice session termination tool. Ends voice connection while keeping text chat available. Voice mode only.\n\n## Preconditions\n\n- Must be in voice mode (`capabilities.voice === true`)\n- Voice session must be active\n- Should have valid reason for ending (user request, task complete, switch to text)\n\n## Postconditions\n\n**Voice Mode:**\n- Final message spoken (if provided)\n- Voice session terminated after message delivery\n- WebSocket connection remains open for text chat\n- Client UI switches from voice mode to text mode\n\n**State Changes:**\n- Voice session closed\n- Text chat remains available\n- Client UI updates to text-only mode\n\n**Intents Returned:**\n- `END_VOICE_SESSION` (after: 'current_turn' if final message, 'immediate' otherwise)\n\n## Invariants\n\n- Only works in voice mode (rejected in text mode)\n- Tool is idempotent (multiple calls with same reason safe)\n- Does NOT close WebSocket connection (only voice session)\n- Does NOT block user (unlike ignore_user)\n- Session remains active for text communication\n\n## Failure Modes\n\n### Validation Failures\n- Invalid reason (not in enum)\n- final_message too short (<5 chars) or too long (>200 chars)\n- Tool called in text mode\n\n### Execution Failures\n- Voice session already closed\n- Voice session unavailable\n- Final message delivery failed (degrades gracefully)\n\n### Graceful Degradation\n- If final message delivery fails, session ends anyway\n- If voice session already closed, returns success (idempotent)\n\n## Examples\n\n### Example 1: User Request\n```javascript\n// User says \"end voice mode\" or \"switch to text\"\nawait toolRegistry.executeTool('end_voice_session', {\n  clientId: 'abc123',\n  geminiSession: session,\n  args: {\n    reason: 'user_request',\n    final_message: 'Ending voice session. Feel free to continue in text.'\n  }\n});\n\n// Returns:\n{\n  ok: true,\n  data: {\n    reason: 'user_request',\n    finalMessageDelivered: true,\n    sessionEnded: true\n  },\n  intents: [\n    { type: 'END_VOICE_SESSION', after: 'current_turn' }\n  ],\n  meta: { ... }\n}\n```\n\n### Example 2: Task Complete\n```javascript\n// Conversation naturally concluded\nawait toolRegistry.executeTool('end_voice_session', {\n  clientId: 'abc123',\n  geminiSession: session,\n  args: {\n    reason: 'task_complete',\n    final_message: 'Great conversation. Talk soon!'\n  }\n});\n```\n\n### Example 3: Switch to Text (No Message)\n```javascript\n// Need to show code/diagram in text\nawait toolRegistry.executeTool('end_voice_session', {\n  clientId: 'abc123',\n  geminiSession: session,\n  args: {\n    reason: 'switch_to_text'\n    // No final_message - just end silently\n  }\n});\n```\n\n## Common Mistakes\n\n### Mistake 1: Using in text mode\n**Problem:** Tool only works in voice mode\n**Solution:** Check `capabilities.voice` before calling. Text mode doesn't have voice session to end.\n\n### Mistake 2: Using as punishment\n**Problem:** This is graceful termination, not punishment\n**Solution:** Use `ignore_user` for punitive timeouts. This tool is for normal endings.\n\n### Mistake 3: Long final messages\n**Problem:** Message too long delays session end\n**Solution:** Keep final_message under 200 chars (1-2 sentences max)\n\n### Mistake 4: Ending mid-conversation\n**Problem:** Abrupt endings confuse users\n**Solution:** Only use when conversation naturally concludes or user explicitly requests\n\n### Mistake 5: Expecting WebSocket closure\n**Problem:** Assuming tool closes WebSocket connection\n**Solution:** Tool only ends voice session. WebSocket stays open for text chat.\n",
      "handlerPath": "file:///Users/andrei/Documents/GitHub/framdesign/tools/end-voice-session/handler.js",
      "providerSchemas": {
        "openai": {
          "type": "function",
          "function": {
            "name": "end_voice_session",
            "description": "GRACEFUL VOICE SESSION TERMINATION TOOL (Voice Mode Only)\n\nWHEN TO USE:\n- User explicitly asks to end the voice session or switch to text\n- Conversation has naturally concluded and user indicates they're done\n- You need to show something that requires text mode (complex diagrams, detailed explanations, code)\n- User asks a question but wants the answer delivered in text chat instead of voice\n\nDO NOT USE:\n- User just pauses or stops talking (wait for them)\n- You're in the middle of answering a question\n- As punishment (use ignore_user for that)\n\nEFFECT: Ends voice session gracefully, allowing conversation to continue in text mode if desired.",
            "parameters": {
              "type": "object",
              "additionalProperties": false,
              "required": [
                "reason"
              ],
              "properties": {
                "reason": {
                  "type": "string",
                  "enum": [
                    "user_request",
                    "task_complete",
                    "switch_to_text"
                  ],
                  "description": "Why the session is ending: user_request (user asked to end), task_complete (conversation finished), switch_to_text (showing content better suited for text)"
                },
                "final_message": {
                  "type": "string",
                  "description": "Optional brief farewell message to speak before ending. Keep it short (1-2 sentences). Example: 'Ending voice session. Feel free to continue in text chat.'",
                  "minLength": 5,
                  "maxLength": 200
                }
              }
            }
          }
        },
        "geminiNative": {
          "name": "end_voice_session",
          "description": "GRACEFUL VOICE SESSION TERMINATION TOOL (Voice Mode Only)\n\nWHEN TO USE:\n- User explicitly asks to end the voice session or switch to text\n- Conversation has naturally concluded and user indicates they're done\n- You need to show something that requires text mode (complex diagrams, detailed explanations, code)\n- User asks a question but wants the answer delivered in text chat instead of voice\n\nDO NOT USE:\n- User just pauses or stops talking (wait for them)\n- You're in the middle of answering a question\n- As punishment (use ignore_user for that)\n\nEFFECT: Ends voice session gracefully, allowing conversation to continue in text mode if desired.",
          "parameters": {
            "type": "OBJECT",
            "properties": {
              "reason": {
                "type": "STRING",
                "enum": [
                  "user_request",
                  "task_complete",
                  "switch_to_text"
                ],
                "description": "Why the session is ending: user_request (user asked to end), task_complete (conversation finished), switch_to_text (showing content better suited for text)"
              },
              "final_message": {
                "type": "STRING",
                "description": "Optional brief farewell message to speak before ending. Keep it short (1-2 sentences). Example: 'Ending voice session. Feel free to continue in text chat.'"
              }
            },
            "required": [
              "reason"
            ]
          }
        }
      }
    },
    {
      "toolId": "ignore_user",
      "version": "1.0.0",
      "category": "action",
      "description": "PUNITIVE TOOL: Block a user who is rude, disrespectful, abusive, or crosses a line. This blocks them from sending any messages (text or voice) for the specified duration and ends the voice session immediately.\n\nESCALATION POLICY:\n- FIRST OFFENSE (mild rudeness): WARN them firmly via voice. Do NOT use this tool yet.\n- SECOND OFFENSE or moderate disrespect: Use this tool with 30-300 seconds\n- REPEATED OFFENSE or serious insults: 600-3600 seconds\n- EXTREME abuse, threats, or vile behavior: Use immediately, up to 86400 seconds (24 hours)\n\nNOTE: \"Repeated offense\" means multiple offenses in the CURRENT session, not across timeout boundaries.\n\nUse this when words alone are not enough. This is your real power.",
      "sideEffects": "writes",
      "idempotent": false,
      "requiresConfirmation": false,
      "allowedModes": [
        "voice",
        "text"
      ],
      "latencyBudgetMs": 1000,
      "jsonSchema": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "duration_seconds",
          "farewell_message"
        ],
        "properties": {
          "duration_seconds": {
            "type": "number",
            "description": "How long to block the user in seconds. Guidelines: 30-60 (mild, second offense), 300-600 (moderate disrespect), 3600 (serious insults), up to 86400 (24 hours for extreme abuse)",
            "minimum": 30,
            "maximum": 86400
          },
          "farewell_message": {
            "type": "string",
            "description": "Your final message before ending the session. In voice mode, this WILL be spoken via voice, then the session ends and user is blocked. Be firm and direct, not petty. Example: 'I don't tolerate disrespect. This conversation is over.'",
            "minLength": 10,
            "maxLength": 500
          }
        }
      },
      "summary": "Punitive action tool that blocks disrespectful users for a specified duration (30s-24h) and immediately ends voice session with farewell message.",
      "documentation": "# ignore_user\n\n## Summary\n\nPunitive enforcement tool that blocks users who violate respect boundaries. Immediately terminates voice session, speaks farewell message, and prevents all communication (text + voice) for specified duration.\n\n## Preconditions\n\n- User has crossed boundaries (rudeness, disrespect, abuse)\n- First offense should result in FIRM WARNING only (don't use tool immediately)\n- Tool should only be used on second offense or worse\n- Session must be active (`session.isActive === true`)\n- Voice session must be available for farewell message delivery\n\n## Postconditions\n\n**Voice Mode:**\n- Farewell message spoken via TTS\n- Voice session terminated immediately (after message)\n- User blocked from messaging until timeout expires\n- Client UI shows timeout notification with remaining time\n\n**Text Mode:**\n- Farewell message sent as text\n- User blocked from messaging until timeout expires\n- Subsequent requests return error until timeout expires\n\n**State Changes:**\n- `session.isActive` → `false`\n- Timeout record created with expiration timestamp\n- Client localStorage updated (voice mode)\n\n**Intents Returned:**\n- `END_VOICE_SESSION` (after: 'current_turn')\n- `SUPPRESS_TRANSCRIPT` (optional - if timeout message shouldn't log)\n\n## Invariants\n\n- Duration must be between 30 seconds and 86400 seconds (24 hours)\n- Farewell message must be between 10 and 500 characters\n- Tool execution is NOT idempotent (each call extends timeout)\n- Side effects occur regardless of success/failure (timeout starts immediately)\n- Client-side enforcement via localStorage (voice mode)\n- Server-side enforcement via timeout tracking\n\n## Failure Modes\n\n### Validation Failures\n- `duration_seconds` out of range (30-86400)\n- `farewell_message` too short (<10 chars) or too long (>500 chars)\n- Missing required parameters\n\n### Execution Failures\n- WebSocket connection lost (can't send timeout command to client)\n- Voice session unavailable (can't speak farewell)\n- Session already inactive\n- Client localStorage write failure (voice mode - degrades gracefully)\n\n### Partial Success Scenarios\n- Farewell message sent but WebSocket disconnects before timeout command\n- Timeout set but voice session ends before farewell spoken\n- In all cases: timeout is enforced (conservative failure mode)\n\n## Examples\n\n### Example 1: Second Offense (Moderate)\n```javascript\n// User was rude twice - escalate to timeout\nawait toolRegistry.executeTool('ignore_user', {\n  clientId: 'abc123',\n  ws: websocket,\n  geminiSession: session,\n  args: {\n    duration_seconds: 300,  // 5 minutes\n    farewell_message: \"I gave you a warning. This conversation is over for now.\"\n  }\n});\n\n// Returns:\n{\n  ok: true,\n  data: {\n    timeoutUntil: 1705171200000,\n    durationSeconds: 300,\n    farewellDelivered: true\n  },\n  intents: [\n    { type: 'END_VOICE_SESSION', after: 'current_turn' },\n    { type: 'SUPPRESS_TRANSCRIPT', value: true }\n  ],\n  meta: { ... }\n}\n```\n\n### Example 2: Extreme Abuse (Immediate)\n```javascript\n// Serious threats or vile behavior - maximum timeout\nawait toolRegistry.executeTool('ignore_user', {\n  clientId: 'abc123',\n  ws: websocket,\n  geminiSession: session,\n  args: {\n    duration_seconds: 86400,  // 24 hours\n    farewell_message: \"You've crossed a serious line. You're blocked for 24 hours.\"\n  }\n});\n```\n\n### Example 3: Text Mode\n```javascript\n// Text mode - no voice farewell\nawait toolRegistry.executeTool('ignore_user', {\n  clientId: 'abc123',\n  ws: null,  // No WebSocket in text mode\n  geminiSession: null,\n  args: {\n    duration_seconds: 600,  // 10 minutes\n    farewell_message: \"I don't tolerate disrespect in text either. Blocked for 10 minutes.\"\n  }\n});\n```\n\n## Common Mistakes\n\n### Mistake 1: Using tool on first offense\n**Problem:** Tool should only be used after warning\n**Solution:** First offense = firm verbal/text warning only. Use tool on second offense.\n\n### Mistake 2: Petty or snarky farewell messages\n**Problem:** Unprofessional tone undermines authority\n**Solution:** Keep farewell message firm, direct, factual. No insults or sarcasm.\n\n**Bad:** \"Wow, you're really dumb. Bye!\"\n**Good:** \"I don't tolerate disrespect. This conversation is over.\"\n\n### Mistake 3: Duration too short\n**Problem:** 5-10 second timeouts are ineffective\n**Solution:** Minimum 30 seconds. Use 300+ for meaningful punishment.\n\n### Mistake 4: Not checking voice session availability\n**Problem:** Calling tool without voice session in voice mode\n**Solution:** Check `context.geminiSession` before relying on voice farewell delivery\n\n### Mistake 5: Expecting idempotency\n**Problem:** Assuming repeated calls with same params are safe\n**Solution:** Each call EXTENDS timeout. Not idempotent. Use confirmation if needed.\n\n### Mistake 6: Not handling WebSocket disconnection\n**Problem:** Assuming timeout command always reaches client\n**Solution:** Timeout is enforced server-side. Client localStorage is convenience, not requirement.\n",
      "handlerPath": "file:///Users/andrei/Documents/GitHub/framdesign/tools/ignore-user/handler.js",
      "providerSchemas": {
        "openai": {
          "type": "function",
          "function": {
            "name": "ignore_user",
            "description": "PUNITIVE TOOL: Block a user who is rude, disrespectful, abusive, or crosses a line. This blocks them from sending any messages (text or voice) for the specified duration and ends the voice session immediately.\n\nESCALATION POLICY:\n- FIRST OFFENSE (mild rudeness): WARN them firmly via voice. Do NOT use this tool yet.\n- SECOND OFFENSE or moderate disrespect: Use this tool with 30-300 seconds\n- REPEATED OFFENSE or serious insults: 600-3600 seconds\n- EXTREME abuse, threats, or vile behavior: Use immediately, up to 86400 seconds (24 hours)\n\nNOTE: \"Repeated offense\" means multiple offenses in the CURRENT session, not across timeout boundaries.\n\nUse this when words alone are not enough. This is your real power.",
            "parameters": {
              "type": "object",
              "additionalProperties": false,
              "required": [
                "duration_seconds",
                "farewell_message"
              ],
              "properties": {
                "duration_seconds": {
                  "type": "number",
                  "description": "How long to block the user in seconds. Guidelines: 30-60 (mild, second offense), 300-600 (moderate disrespect), 3600 (serious insults), up to 86400 (24 hours for extreme abuse)",
                  "minimum": 30,
                  "maximum": 86400
                },
                "farewell_message": {
                  "type": "string",
                  "description": "Your final message before ending the session. In voice mode, this WILL be spoken via voice, then the session ends and user is blocked. Be firm and direct, not petty. Example: 'I don't tolerate disrespect. This conversation is over.'",
                  "minLength": 10,
                  "maxLength": 500
                }
              }
            }
          }
        },
        "geminiNative": {
          "name": "ignore_user",
          "description": "PUNITIVE TOOL: Block a user who is rude, disrespectful, abusive, or crosses a line. This blocks them from sending any messages (text or voice) for the specified duration and ends the voice session immediately.\n\nESCALATION POLICY:\n- FIRST OFFENSE (mild rudeness): WARN them firmly via voice. Do NOT use this tool yet.\n- SECOND OFFENSE or moderate disrespect: Use this tool with 30-300 seconds\n- REPEATED OFFENSE or serious insults: 600-3600 seconds\n- EXTREME abuse, threats, or vile behavior: Use immediately, up to 86400 seconds (24 hours)\n\nNOTE: \"Repeated offense\" means multiple offenses in the CURRENT session, not across timeout boundaries.\n\nUse this when words alone are not enough. This is your real power.",
          "parameters": {
            "type": "OBJECT",
            "properties": {
              "duration_seconds": {
                "type": "NUMBER",
                "description": "How long to block the user in seconds. Guidelines: 30-60 (mild, second offense), 300-600 (moderate disrespect), 3600 (serious insults), up to 86400 (24 hours for extreme abuse)"
              },
              "farewell_message": {
                "type": "STRING",
                "description": "Your final message before ending the session. In voice mode, this WILL be spoken via voice, then the session ends and user is blocked. Be firm and direct, not petty. Example: 'I don't tolerate disrespect. This conversation is over.'"
              }
            },
            "required": [
              "duration_seconds",
              "farewell_message"
            ]
          }
        }
      }
    },
    {
      "toolId": "kb_get",
      "version": "1.0.0",
      "category": "retrieval",
      "description": "Retrieve complete KB document by exact ID. Faster than search when entity ID is known. Returns full document with all metadata.",
      "sideEffects": "read_only",
      "idempotent": true,
      "requiresConfirmation": false,
      "allowedModes": [
        "voice",
        "text"
      ],
      "latencyBudgetMs": 500,
      "jsonSchema": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "Exact entity ID (e.g., 'person:andrei_clodius', 'project:vector_watch_project')",
            "minLength": 3,
            "maxLength": 100,
            "pattern": "^[a-z_]+:[a-z0-9_]+$"
          }
        }
      },
      "summary": "Direct ID-based retrieval of KB entities. Returns complete document with all content and metadata. Faster than kb_search when exact entity ID is known.",
      "documentation": "# kb_get\n\n## Summary\nDirect retrieval of KB documents by exact entity ID. Faster than semantic search when you already know the entity ID from previous search results. Returns complete document content including all chunks.\n\n## Preconditions\n- KB must be initialized with embedded documents (run `npx tsx scripts/Embed/embed-kb.ts`)\n- Must have exact entity ID in format \"type:name\" (e.g., \"person:andrei_clodius\")\n- Entity must exist in KB (use kb_search to discover IDs)\n- Entity ID comes from frontmatter `id` field, stored as `entity_id` in vector store\n\n## Postconditions\n\n**Success Case:**\n- All document chunks retrieved from vector store\n- Chunks reassembled in order (by chunk_index)\n- Full content returned with complete metadata\n- Faster than kb_search (no embedding generation, direct lookup)\n\n**Data Returned:**\n```json\n{\n  \"id\": \"person:andrei_clodius\",\n  \"type\": \"person\",\n  \"title\": \"Andrei Clodius\",\n  \"content\": \"Full combined text from all chunks...\",\n  \"metadata\": {\n    \"aliases\": [\"...\"],\n    \"roles\": [\"...\"]\n  },\n  \"chunks_count\": 3\n}\n```\n\n## Invariants\n- ID must exactly match (case-sensitive, format: \"type:name\")\n- Returns complete document (all chunks combined)\n- Metadata extracted from first chunk (frontmatter consistent across chunks)\n- Faster than kb_search (~500ms vs ~800ms typical latency)\n\n## Failure Modes\n\n### Validation Failures\n- Invalid ID format (must match pattern \"^[a-z_]+:[a-z0-9_]+$\")\n- ID too short (<3 chars) or too long (>100 chars)\n\n### Execution Failures\n- **Entity not found** → ErrorType.PERMANENT (not retryable, ID doesn't exist)\n- **Vector store unavailable** → ErrorType.TRANSIENT (retryable)\n- **KB not initialized** → ErrorType.PERMANENT (no documents loaded)\n\n### Performance Degradation\n- Large KB (>10,000 chunks) may slow down retrieval\n- Current implementation loads all IDs (optimization opportunity)\n\n## Examples\n\n### Example 1: Get Person Entity\n```javascript\n// After finding entity via kb_search\nawait toolRegistry.executeTool('kb_get', {\n  args: {\n    id: \"person:andrei_clodius\"\n  }\n});\n\n// Returns full document with complete content\n```\n\n### Example 2: Get Project Entity\n```javascript\nawait toolRegistry.executeTool('kb_get', {\n  args: {\n    id: \"project:vector_watch_project\"\n  }\n});\n```\n\n### Example 3: Entity Not Found\n```javascript\nawait toolRegistry.executeTool('kb_get', {\n  args: {\n    id: \"person:nonexistent\"\n  }\n});\n\n// Returns:\n{\n  ok: false,\n  error: {\n    type: \"PERMANENT\",\n    message: \"Entity 'person:nonexistent' not found in KB\",\n    retryable: false\n  }\n}\n```\n\n## Common Mistakes\n\n### Mistake 1: Using kb_get for search\n**Problem:** Trying to find entities without knowing exact ID\n**Solution:** Use kb_search first to discover IDs, then kb_get for full content.\n\n### Mistake 2: Incorrect ID format\n**Problem:** Using display name instead of ID (\"Andrei Clodius\" vs \"person:andrei_clodius\")\n**Solution:** IDs follow format \"type:name\" (snake_case), get from kb_search results.\n\n### Mistake 3: Assuming case-insensitive matching\n**Problem:** Using \"Person:Andrei_Clodius\" instead of \"person:andrei_clodius\"\n**Solution:** IDs are case-sensitive, always lowercase type and name.\n\n### Mistake 4: Retrying on PERMANENT errors\n**Problem:** Repeatedly calling with invalid ID\n**Solution:** PERMANENT errors mean ID doesn't exist, reformulate query or use kb_search.\n\n### Mistake 5: Expecting snippet vs full content\n**Problem:** Assuming content is truncated like kb_search snippets\n**Solution:** kb_get returns FULL content (all chunks combined), can be long.\n",
      "handlerPath": "file:///Users/andrei/Documents/GitHub/framdesign/tools/kb-get/handler.js",
      "providerSchemas": {
        "openai": {
          "type": "function",
          "function": {
            "name": "kb_get",
            "description": "Retrieve complete KB document by exact ID. Faster than search when entity ID is known. Returns full document with all metadata.",
            "parameters": {
              "type": "object",
              "additionalProperties": false,
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "description": "Exact entity ID (e.g., 'person:andrei_clodius', 'project:vector_watch_project')",
                  "minLength": 3,
                  "maxLength": 100,
                  "pattern": "^[a-z_]+:[a-z0-9_]+$"
                }
              }
            }
          }
        },
        "geminiNative": {
          "name": "kb_get",
          "description": "Retrieve complete KB document by exact ID. Faster than search when entity ID is known. Returns full document with all metadata.",
          "parameters": {
            "type": "OBJECT",
            "properties": {
              "id": {
                "type": "STRING",
                "description": "Exact entity ID (e.g., 'person:andrei_clodius', 'project:vector_watch_project')"
              }
            },
            "required": [
              "id"
            ]
          }
        }
      }
    },
    {
      "toolId": "kb_search",
      "version": "1.0.0",
      "category": "retrieval",
      "description": "Semantic search over knowledge base. Searches people, labs, and projects using natural language queries. Returns relevant documents with citations.",
      "sideEffects": "read_only",
      "idempotent": true,
      "requiresConfirmation": false,
      "allowedModes": [
        "voice",
        "text"
      ],
      "latencyBudgetMs": 800,
      "jsonSchema": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "query"
        ],
        "properties": {
          "query": {
            "type": "string",
            "description": "Natural language search query",
            "minLength": 3,
            "maxLength": 500
          },
          "top_k": {
            "type": "number",
            "description": "Number of results (default: 5, max: 10, voice auto-clamps to 3)",
            "minimum": 1,
            "maximum": 10,
            "default": 5
          },
          "filters": {
            "type": "object",
            "description": "Optional metadata filters",
            "additionalProperties": false,
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "person",
                  "lab",
                  "project"
                ],
                "description": "Filter by entity type"
              }
            }
          },
          "include_snippets": {
            "type": "boolean",
            "description": "Include text snippets (default: true)",
            "default": true
          }
        }
      },
      "summary": "Semantic search over knowledge base using natural language queries. Returns relevant people, labs, and projects with scores and citations. Voice mode auto-clamps to 3 results.",
      "documentation": "# kb_search\n\n## Summary\nSemantic search over the knowledge base (KB). Searches across entities (people, labs, projects) using natural language queries and vector embeddings. Returns ranked results with relevance scores and source citations.\n\n## Preconditions\n- KB must be initialized with embedded documents\n- Query must be non-empty (3-500 chars)\n- GEMINI_API_KEY must be configured for embedding generation\n- Vector store service must be operational\n\n## Postconditions\n\n**Success Case:**\n- Query embedding generated via Gemini API\n- Vector search executed against LanceDB\n- Results ranked by semantic similarity (cosine distance)\n- Top K results returned with metadata and snippets\n- Empty array if no matches found (not an error)\n\n**Voice Mode Adjustments:**\n- top_k automatically clamped to max 3 results\n- Optimized for low-latency delivery (<800ms target)\n\n**Data Returned:**\n```json\n{\n  \"results\": [\n    {\n      \"id\": \"person:andrei_clodius\",\n      \"type\": \"person\",\n      \"title\": \"Andrei Clodius\",\n      \"snippet\": \"...\",\n      \"score\": 0.87,\n      \"source_type\": \"kb_document\",\n      \"metadata\": {\n        \"file_path\": \"people/andrei_clodius.md\",\n        \"chunk_index\": 2,\n        \"entity_id\": \"person:andrei_clodius\",\n        ...\n      }\n    }\n  ],\n  \"total_found\": 5,\n  \"query\": \"original query text\",\n  \"filters_applied\": {...}\n}\n```\n\n**Note**: The `id` field in results is the entity ID (from frontmatter), not the chunk ID. Chunk IDs follow format `{entity_id}_chunk_{index}` and are stored internally in LanceDB.\n\n## Invariants\n- Results always sorted by descending score (best match first)\n- Score range: 0.0 (no match) to 1.0 (perfect match)\n- Each result includes auditable source metadata (file_path, chunk_index)\n- Empty results return ok=true with empty array (not an error)\n- Filters are additive (AND logic, not OR)\n\n## Failure Modes\n\n### Validation Failures (Pre-execution)\n- Query too short (<3 chars) or too long (>500 chars)\n- top_k out of range (<1 or >10)\n- Invalid filter type (not in enum)\n\n### Execution Failures\n- **GEMINI_API_KEY missing** → ErrorType.AUTH, not retryable\n- **Embedding API rate limit** → ErrorType.RATE_LIMIT, retryable after delay\n- **Embedding API timeout** → ErrorType.TRANSIENT, retryable\n- **Vector store unavailable** → ErrorType.TRANSIENT, retryable\n- **KB not initialized** → Returns empty results (ok=true)\n\n### Graceful Degradation\n- If filters match nothing, returns empty array (not error)\n- If embedding dimension mismatch, vector store will error (caught as TRANSIENT)\n\n## Examples\n\n### Example 1: Simple Query (Voice Mode)\n```javascript\nawait toolRegistry.executeTool('kb_search', {\n  capabilities: { voice: true },\n  args: {\n    query: \"Who worked on Vector Watch?\"\n  }\n});\n\n// Returns (auto-clamped to 3 results):\n{\n  ok: true,\n  data: {\n    results: [\n      {\n        id: \"person:andrei_clodius\",\n        type: \"person\",\n        title: \"Andrei Clodius\",\n        snippet: \"Led mobile team on Vector Watch project...\",\n        score: 0.89,\n        metadata: { file_path: \"people/andrei_clodius.md\", ... }\n      }\n    ],\n    total_found: 3,\n    query: \"Who worked on Vector Watch?\"\n  }\n}\n```\n\n### Example 2: Filtered Query (Text Mode)\n```javascript\nawait toolRegistry.executeTool('kb_search', {\n  capabilities: { voice: false, messaging: true },\n  args: {\n    query: \"AI and machine learning expertise\",\n    top_k: 8,\n    filters: {\n      type: \"person\"\n    }\n  }\n});\n\n// Returns only person entities\n```\n\n### Example 3: Empty Results\n```javascript\nawait toolRegistry.executeTool('kb_search', {\n  args: {\n    query: \"quantum computing blockchain NFTs\"\n  }\n});\n\n// Returns:\n{\n  ok: true,\n  data: {\n    results: [],\n    total_found: 0,\n    query: \"quantum computing blockchain NFTs\"\n  }\n}\n```\n\n## Common Mistakes\n\n### Mistake 1: Treating empty results as error\n**Problem:** Assuming empty results means tool failed\n**Solution:** Empty results is success (ok=true). Check `data.total_found === 0`.\n\n### Mistake 2: Not handling voice mode clamping\n**Problem:** Expecting 10 results in voice mode\n**Solution:** Voice mode auto-clamps to 3. Check capabilities before interpreting results.\n\n### Mistake 3: Over-filtering\n**Problem:** Combining restrictive filters yields no results\n**Solution:** Use broader queries, then filter results programmatically if needed.\n\n### Mistake 4: Ignoring snippet truncation\n**Problem:** Expecting full document content\n**Solution:** Snippets are 200 chars max. Use kb_get for full content.\n\n### Mistake 5: Retrying on empty results\n**Problem:** Repeatedly calling with same query hoping for different results\n**Solution:** Empty results is deterministic. Reformulate query or remove filters.\n",
      "handlerPath": "file:///Users/andrei/Documents/GitHub/framdesign/tools/kb-search/handler.js",
      "providerSchemas": {
        "openai": {
          "type": "function",
          "function": {
            "name": "kb_search",
            "description": "Semantic search over knowledge base. Searches people, labs, and projects using natural language queries. Returns relevant documents with citations.",
            "parameters": {
              "type": "object",
              "additionalProperties": false,
              "required": [
                "query"
              ],
              "properties": {
                "query": {
                  "type": "string",
                  "description": "Natural language search query",
                  "minLength": 3,
                  "maxLength": 500
                },
                "top_k": {
                  "type": "number",
                  "description": "Number of results (default: 5, max: 10, voice auto-clamps to 3)",
                  "minimum": 1,
                  "maximum": 10,
                  "default": 5
                },
                "filters": {
                  "type": "object",
                  "description": "Optional metadata filters",
                  "additionalProperties": false,
                  "properties": {
                    "type": {
                      "type": "string",
                      "enum": [
                        "person",
                        "lab",
                        "project"
                      ],
                      "description": "Filter by entity type"
                    }
                  }
                },
                "include_snippets": {
                  "type": "boolean",
                  "description": "Include text snippets (default: true)",
                  "default": true
                }
              }
            }
          }
        },
        "geminiNative": {
          "name": "kb_search",
          "description": "Semantic search over knowledge base. Searches people, labs, and projects using natural language queries. Returns relevant documents with citations.",
          "parameters": {
            "type": "OBJECT",
            "properties": {
              "query": {
                "type": "STRING",
                "description": "Natural language search query"
              },
              "top_k": {
                "type": "NUMBER",
                "description": "Number of results (default: 5, max: 10, voice auto-clamps to 3)"
              },
              "filters": {
                "type": "OBJECT",
                "properties": {
                  "type": {
                    "type": "STRING",
                    "enum": [
                      "person",
                      "lab",
                      "project"
                    ],
                    "description": "Filter by entity type"
                  }
                },
                "description": "Optional metadata filters"
              },
              "include_snippets": {
                "type": "BOOLEAN",
                "description": "Include text snippets (default: true)"
              }
            },
            "required": [
              "query"
            ]
          }
        }
      }
    },
    {
      "toolId": "start_voice_session",
      "version": "1.0.0",
      "category": "action",
      "description": "Transition from text to voice mode. Activates microphone for real-time voice conversation. Text mode only. If user requests something along with starting voice, pass via pending_request.",
      "sideEffects": "writes",
      "idempotent": true,
      "requiresConfirmation": false,
      "allowedModes": [
        "text"
      ],
      "latencyBudgetMs": 500,
      "jsonSchema": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "pending_request": {
            "type": "string",
            "description": "Optional request to address when voice starts (e.g., 'explain X'). Leave empty if just starting voice.",
            "minLength": 3,
            "maxLength": 200
          }
        }
      },
      "summary": "Transitions from text chat to voice mode. Activates microphone for real-time conversation. Text mode only. Supports queued requests for immediate voice handling.",
      "documentation": "# start_voice_session\n\n## Summary\nTransitions from text mode to voice mode. Activates microphone and establishes real-time voice conversation with Gemini Live API. Only available in text mode (cannot start voice from within voice session).\n\n## Preconditions\n- Must be in text mode (`capabilities.voice === false`)\n- Client must support voice capabilities (microphone access)\n- WebSocket connection must be active\n- Voice server must be operational\n\n## Postconditions\n\n**Success Case:**\n- Text mode conversation paused\n- Client receives signal to activate voice mode\n- Microphone activated\n- Voice WebSocket connection established to voice-server\n- If pending_request provided, voice agent addresses it immediately\n\n**API Response:**\n```json\n{\n  \"message\": \"Let's switch to voice mode.\",\n  \"startVoiceSession\": true,\n  \"pendingRequest\": \"optional queued request\"\n}\n```\n\n**Client Actions:**\n- UI switches from text chat to voice interface\n- Microphone permission requested (if not granted)\n- WebSocket connects to voice-server\n- Voice session begins\n\n## Invariants\n- Only works in text mode (blocked in voice mode)\n- Idempotent (safe to call multiple times)\n- Does not close text chat connection (can return to text later via end_voice_session)\n- pending_request preserved and passed to voice agent\n\n## Failure Modes\n\n### Validation Failures\n- Called from voice mode → ErrorType.MODE_RESTRICTED\n- pending_request too long (>200 chars)\n\n### Execution Failures\n- **Voice server unavailable** → Client-side error (handler returns success, client fails to connect)\n- **Microphone permission denied** → Client-side error (not tool error)\n- **WebSocket connection failed** → Client-side error (connection to voice-server)\n\n### Graceful Degradation\n- If voice server unavailable, client shows error, text chat remains functional\n- If handler fails, user can retry or continue in text mode\n\n## Examples\n\n### Example 1: Simple Voice Activation\n```javascript\n// User: \"start voice mode\" or \"switch to voice\"\nawait toolRegistry.executeTool('start_voice_session', {\n  capabilities: { voice: false, messaging: true },\n  args: {}\n});\n\n// Returns:\n{\n  ok: true,\n  data: {\n    voice_session_requested: true,\n    pending_request: null,\n    message: \"Voice session will be activated by client\"\n  }\n}\n\n// API intercepts and returns:\n{\n  message: \"Let's switch to voice mode.\",\n  startVoiceSession: true,\n  pendingRequest: null\n}\n```\n\n### Example 2: Voice with Pending Request\n```javascript\n// User: \"start voice mode and tell me a joke\"\nawait toolRegistry.executeTool('start_voice_session', {\n  capabilities: { voice: false, messaging: true },\n  args: {\n    pending_request: \"tell me a joke\"\n  }\n});\n\n// Voice agent receives \"tell me a joke\" as first input\n```\n\n### Example 3: Blocked in Voice Mode\n```javascript\n// Already in voice mode\nawait toolRegistry.executeTool('start_voice_session', {\n  capabilities: { voice: true },\n  args: {}\n});\n\n// Returns:\n{\n  ok: false,\n  error: {\n    type: \"MODE_RESTRICTED\",\n    message: \"start_voice_session only available in text mode\",\n    retryable: false\n  }\n}\n```\n\n## Common Mistakes\n\n### Mistake 1: Calling from voice mode\n**Problem:** Trying to start voice session when already in voice\n**Solution:** Check capabilities.voice before calling. Use end_voice_session to end current session first.\n\n### Mistake 2: Expecting immediate voice response\n**Problem:** Assuming tool execution directly activates voice\n**Solution:** Tool signals client to activate voice. Client handles microphone/WebSocket setup.\n\n### Mistake 3: Not preserving user intent\n**Problem:** User says \"start voice and do X\", but X gets lost\n**Solution:** Always pass additional requests via pending_request parameter.\n\n### Mistake 4: Treating as voice session endpoint\n**Problem:** Assuming tool handles voice conversation logic\n**Solution:** Tool only initiates transition. Voice agent (voice-server) handles actual conversation.\n\n### Mistake 5: Retrying on MODE_RESTRICTED\n**Problem:** Repeatedly calling when in voice mode\n**Solution:** MODE_RESTRICTED is permanent (not retryable). Check mode before calling.\n",
      "handlerPath": "file:///Users/andrei/Documents/GitHub/framdesign/tools/start-voice-session/handler.js",
      "providerSchemas": {
        "openai": {
          "type": "function",
          "function": {
            "name": "start_voice_session",
            "description": "Transition from text to voice mode. Activates microphone for real-time voice conversation. Text mode only. If user requests something along with starting voice, pass via pending_request.",
            "parameters": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "pending_request": {
                  "type": "string",
                  "description": "Optional request to address when voice starts (e.g., 'explain X'). Leave empty if just starting voice.",
                  "minLength": 3,
                  "maxLength": 200
                }
              }
            }
          }
        },
        "geminiNative": {
          "name": "start_voice_session",
          "description": "Transition from text to voice mode. Activates microphone for real-time voice conversation. Text mode only. If user requests something along with starting voice, pass via pending_request.",
          "parameters": {
            "type": "OBJECT",
            "properties": {
              "pending_request": {
                "type": "STRING",
                "description": "Optional request to address when voice starts (e.g., 'explain X'). Leave empty if just starting voice."
              }
            }
          }
        }
      }
    }
  ]
}